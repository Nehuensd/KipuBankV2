// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

//Title Kipubank
//@author Nehuen
//@notice Simple banking for ETH deposits with personal vaults, global limit and immutable withdrawal limit.
//@dev checks-effects-interactions, use of modifiers and secure native transfers
contract KipuBank is AccessControl{
using SafeERC20 for IERC20;

//@notice Error notice when 0 is sent as quantity
error kipuZeroAmount();

//@notice Error notice when deposit global is full
//@param attempedAmount excess amount
//@param availableRemaining remaining amount allowed before reaching bankCap
error kipuBankCapExceeded (uint256 attempedAmount, uint256 availableRemaining);

//@notice Error when the amount requested to withdraw exceedes the withdrawal limit
//@param requested Requested quantity
//@param limit Limit for requested
error kipuWithdrawalLimitExceeded(uint256 requested, uint256 limit);

//@notice Error user does not have enough balance in his vault
//@param requested Requested quantity
//@param balance Balance in his vault
error kipuInsufficentBalance(uint256 requested, uint256 balance);

//@notice Error Native transfer by call falls
//@param to Address to which attempted to send
//@param amount Quantity canÂ´t send
error kipuNativeTransferFailed(address to, uint256 amount);

//@notice Role for managers who can perform administrative credits
bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
//@notice Role for users who can perform deposit and withdrawal personal vaults
bytes32 public constant USER_ROLE = keccak256("USER_ROLE");
//@notice Role for multitoken support
bytes32 public constant TOKEN_MANAGE_ROLE = keccak256("TOKKEN_MANAGE_ROLE");

uint256 private _reentrancyStatus;
uint256 private constant _NOT_ENTERED =1;
uint256 private constant _ENTERED =2;

//@notice Limit global max of ETH that the contract accepts as a deposit
uint256 public immutable bankCap;
//@notice Maximum withdrawal limit in a single transaction
uint256 public immutable withdrawalLimit;
//@notice Total accumulated balance stored in the contract
uint256 public totalBanked;

//@notice unified balances: token=>user=>amount ; use address(0) for ETH
mapping(address =>mapping(address=>uint256)) private _balances;

//@notice Total successful deposit counter
uint256 public depositCount;
//@notice Total succesful withdrawal counter
uint256 public withrawalCount;

//@notice Event issued after a successful deposit
//@param user Deposit address
//@param amount Deposit quantity
//@param newBalance New quantity in the personal vault 
//@param depositId Incremental deposit identifier
event Deposit(address indexed user, uint256 amount, uint256 newBalance, uint256 depositId);
//@notice Event issued after a successful deposit in tokens
//@param token
//@param user Deposit address
//@param amount Deposit quantity
//@param newBalance New quantity in the personal vault 
//@param depositId Incremental deposit identifier
event DepositToken(address indexed token, address indexed user, uint256 amount, uint256 newBalance, uint256 depositId);
//@notice Event issued after a successful withdrawal
//@param user Withdrawal address
//@param amount Withdrawal quantity
//@param newBalance New quantity in the personal vault
//@param withdrawalId Incremental withdrawal idenitifier
event withdrawal(address indexed user, uint256 amount, uint256 newBalance, uint256 withdrawalId);
//@notice Event issued after a successful withdrawal
//@param token
//@param user Withdrawal address
//@param amount Withdrawal quantity
//@param newBalance New quantity in the personal vault
//@param withdrawalId Incremental withdrawal idenitifier
event withdrawalToken(address indexed token, address indexed user, uint256 amount, uint256 newBalance, uint256 withdrawalId);
//@notice Grant the user role and open the account
//@param user Address user
//@param openedBy Admin authorizing the opening
event AccountOpened(address indexed user, address indexed openedBy);
//@notice Account closed event
//@param user Address user
//@param openedBy Admin authorizing closure
event AccountClosed(address indexed user, address indexed closedBy);
//@notice Modifier quantity greater than cero
//@param amount Quantity
modifier nonZero(uint256 amount){
    if(amount==0) revert kipuZeroAmount();
    _;
}
//@notice Modifier check that the deposit does not break the banKCap
//@param amount Quiantity
modifier withinBankCap(uint256 amount){
    uint256 remaining = bankCap - totalBanked;
    if(amount>remaining) revert kipuBankCapExceeded(amount,remaining);
    _;
}

modifier nonReentrant(){
    require(_reentrancyStatus==_NOT_ENTERED,"ReentrancyGuard:reentrant call");
    _reentrancyStatus=_ENTERED;
    _;
    _reentrancyStatus=_NOT_ENTERED;
}

//@pragma _bankCap Total global limit acceptable to the bank
//@pragma _withrawalLimit Withdrawal limit per transaction
constructor(uint256 _bankCap, uint256 _withdrawalLimit) payable{
    bankCap=_bankCap;
    withdrawalLimit=_withdrawalLimit;
    totalBanked=0;
    depositCount=0;
    withrawalCount=0;
    _reentrancyStatus=_NOT_ENTERED;

    // Grant admin role to deployer and set manager role to deployer initially
    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    _grantRole(MANAGER_ROLE, msg.sender);
    _grantRole(TOKEN_MANAGE_ROLE, msg.sender);

     if(msg.value>0){
        if(msg.value >bankCap) revert kipuBankCapExceeded(msg.value,bankCap);
        _balances[address(0)][msg.sender]=msg.value;
        totalBanked=msg.value;
        depositCount=1;
        //Grant user role to deployer so they can interact later
        _grantRole(USER_ROLE,msg.sender);
        emit AccountOpened(msg.sender, msg.sender);
        emit Deposit(msg.sender,msg.value,_balances[address(0)][msg.sender],depositCount);
     }
}

//@notice Admin open account and grants USER_ROLE
function openAccount(address user) external onlyRole(DEFAULT_ADMIN_ROLE){
    _grantRole(USER_ROLE,user);
    emit AccountOpened(user,msg.sender);
}

//@notice Admin closed account and revokes USER_ROLE
function closeAccount(address user) external onlyRole(DEFAULT_ADMIN_ROLE){
    _revokeRole(USER_ROLE, user);
    emit AccountClosed(user, msg.sender);
}

//@notice Deposit ETH in the vault
//@dev Checks-effects-interactions: validates cap, updates status, issues event.
//@dev Using modifier withinBankCap to validate global limit
//@return newBalance New user balance after deposit
function deposit() external payable onlyRole(USER_ROLE) nonZero(msg.value) withinBankCap(msg.value) returns (uint256 newBalance){
    //Effects(updates states)
    _balances[address(0)][msg.sender] += msg.value;
    totalBanked+=msg.value;
    //increment counter deposits and emit event
    depositCount+=1;
    newBalance=_balances[address(0)][msg.sender];
    emit Deposit(msg.sender,msg.value,newBalance,depositCount);
    return newBalance;
}
//@notice deposit ERC20 token
function depositToken(address token, uint256 amount) external onlyRole(USER_ROLE) nonZero(amount) returns (uint256 newBalance){
    IERC20(token).safeTransferFrom(msg.sender,address(this),amount);
    _balances[token][msg.sender]+=amount;
    depositCount+=1;
    newBalance=_balances[token][msg.sender];
    emit DepositToken(token,msg.sender,amount,newBalance,depositCount);
    return newBalance;
}

//@notice Withdraws ETH from the sender vault up to the withdrawal limit
//@dev Check requested>0, that requested <=withdrawalLimit and that the user has sufficient balanced
//@param requested Withdrawal quantity
//@return sent True if the transfer was successful
function  withdraw (uint256 requested) external onlyRole(USER_ROLE) nonZero(requested) nonReentrant  returns(bool sent){
//Checks withdrawal limit
if(requested>withdrawalLimit) revert kipuWithdrawalLimitExceeded(requested,withdrawalLimit);
uint256 userBalance = _balances[address(0)][msg.sender];
if(requested>userBalance) revert kipuInsufficentBalance(requested,userBalance);
_balances[address(0)][msg.sender]=userBalance-requested;
totalBanked-=requested;

withrawalCount+=1;
uint256 newBalance=_balances[address(0)][msg.sender];

sent=_sendNative(payable(msg.sender),requested);
if(!sent)revert kipuNativeTransferFailed(msg.sender,requested);
emit withdrawal(msg.sender, requested, newBalance, withrawalCount);
return true;
}
//@notice withraw ERC20 token
function withdrawToken(address token, uint256 amount) external onlyRole(USER_ROLE) nonZero(amount) nonReentrant returns (bool){
    uint256 val=_balances[token][msg.sender];
    if(amount>val) revert kipuInsufficentBalance(amount,val);
    _balances[token][msg.sender]=val-amount;
    withrawalCount+=1;
    IERC20(token).safeTransfer(msg.sender,amount);
    emit withdrawalToken(token, msg.sender, amount, _balances[token][msg.sender], withrawalCount);
    return true;
}

//@notice Balance of the vault of an address
//@param account Address whose vault is consulted
//@return balance Balance in wei
function getBalance(address token, address account) external view onlyRole(USER_ROLE) returns (uint256 balance){
    return _balances[token][account];
}
//@dev Private funcion that centralizes the native shipping logic
//@param to Destine adress payable
//@param amount Quantity in wei to send
//@returns sucess True if the transfer was successful
function _sendNative(address payable to, uint256 amount) private returns (bool success){
    (success,)=to.call{value:amount}("");
    return success;
}
//@notice Manager can credit users without needing them to call deposit
function creditTo(address payable to, uint256 amount) external nonZero(amount) withinBankCap(amount) onlyRole(MANAGER_ROLE) returns(uint256 newBalance){
    _balances[address(0)][to]+=amount;
    totalBanked+=amount;
    depositCount+=1;
    newBalance=_balances[address(0)][to];
    emit Deposit(to,amount,newBalance,depositCount);
    return newBalance;
}

function creditToken(address token, address to, uint256 amount) external nonZero(amount) onlyRole(MANAGER_ROLE) returns(uint256 newBalance){
    IERC20(token).safeTransferFrom(msg.sender,address(this),amount);
    _balances[token][to]+=amount;
    depositCount+=1;
    newBalance=_balances[token][to];
    emit DepositToken(token, to, amount, newBalance, depositCount);
    return newBalance;
}

//@notice Receive fallback to avoid accidental shipments without calling deposit
//@dev Reject direct ETH shipments. We ask that deposit() be called explicitly.
receive() external payable{
    revert kipuZeroAmount();
}
//@notice Fallback who rejects calls without data
fallback() external payable {
    revert kipuZeroAmount();
 }
}
